\#
\# groff-mom source for Honours Project report
\#
\# ===================================================================
\#
\# Metadata
\#
.TITLE "TODO Determine Title"
.AUTHOR "Shane Bishop"
.ATTRIBUTE_STRING ""
.PRINTSTYLE TYPESET
\#
\# This determines what goes on the the cover page
.DOC_COVER TITLE AUTHOR
\#
\# Set up Table of Contents
\#
.AUTO_RELOCATE_TOC
.SPACE_TOC_ITEMS
\#
\# Have captions after labels
\#
.CAPTION_AFTER_LABEL IMG
.CATPION_AFTER_LABEL TBL
\#
\# Use numbered footnotes
\#
.FOOTNOTE_MARKER_STYLE NUMBER
\# Set headings to be numbered
.HEADING_STYLE 1 NUMBER
.HEADING_STYLE 2 NUMBER
.HEADING_STYLE 3 NUMBER
.HEADING_STYLE 4 NUMBER
.HEADING_STYLE 5 NUMBER
\#
\# Pull the custom implementation of PDF_LINK macro from ~/pdf-link.tmac
\# For details, refer to previous email correspondence with Peter Schaffter
\#
.rm PDF_LINK
.mso pdf-link.tmac
\# Set indent for quoting
.QUOTE_INDENT 1
.\" Make QUOTE look like CODE
.\" .QUOTE_STYLE \
.\"   FAMILY C \
.\"   FONT   B \
.\"   SIZE   +1.5 \
.\"   COLOR  dark-grey \
.\"   INDENT 9p
.\"
.\" Color for code snippets
.CODE_STYLE \
  FONT  B \
  SIZE  115 \
.CONDENSE 87 \" Condense percentage used in COD
.\" Strings for inline code
.ds cod  \E*[CODE]\&\E*[COND]
.ds codx \E*[CONDX]\E*[CODE off]\&
\#
\# Use Palatino instead of default Times Roman font
\# If Palatino is unavailable, use Times Roman font
\# TODO Currently doesn't work, but have a question for this: https://unix.stackexchange.com/questions/630457/using-palatino-font-with-groff-mom-macros
\#.FAMILY P
\#.FALLBACK_FONT TR
\#
.START
\#
.HEADING 1 NAMED abstract "Abstract"
.PP
Placeholder text
\#
.HEADING 1 NAMED intro "Introduction"
.PP
Placeholder text
\#
.HEADING 1 NAMED techologies "Tools and Technologies"
.PP
The Dental Appointments system is a full-stack webapp, consisting of a
frontend, backend server, and database. Each layer of the application has
its own tests as appropriate for the language or framework being used for
that layer. This section will describe all of the tools and techologies
employed by this system in terms of both implementation and testing.
.HEADING 2 NAMED technologies_frontend "Frontend"
.PP
The frontend is written in JavaScript using the
.PDF_WWW_LINK https://reactjs.org/ "React"
library. Unit tests for the react code were written using the
.PDF_WWW_LINK https://jestjs.io/ "Jest"
JavaScript testing framework.
.HEADING 2 NAMED technologies_backend "Backend"
.PP
The backend server is written in Python using the
.PDF_WWW_LINK https://www.djangoproject.com/ "Django"
framework. An
additional Python library called
.PDF_WWW_LINK https://www.django-rest-framework.org/ "Django REST framework"
was used to simplify the code for writing the REST APIs.
.PP
The Django framework includes its own built-in testing framework. The API
tests for the backend are written using this built-in testing framework.
.HEADING 2 NAMED technologies_database "Database"
.PP
The database uses the
.PDF_WWW_LINK https://www.postgresql.org/ "PostgreSQL"
relational database management system.
However, the Django framework used in the backend abstracts away all of the
details of PostgreSQL (or any alternative database management system), which
means no actual PostgreSQL code was written "by hand" for this project.
.HEADING 2 NAMED technologies_deployment "Deployment"
.PP
The system is spun up using Docker and \*[cod]docker-compose\*[codx].
.PP
.PDF_WWW_LINK https://www.docker.com/ "Docker"
is a container technology that allows for running an application
under controlled and isolated conditions, often used for fast and easy
application development and deployment. Docker supports reproducible builds,
and any Docker "image" can be rebuilt from the same specification.
.PP
.CODE
.PDF_WWW_LINK https://docs.docker.com/compose/ "docker-compose"
.CODE OFF
is a Docker tool that uses declarative code to define the
deployment of a system consisting of several individual Docker containers.
.HEADING 2 NAMED technologies_acceptance "Acceptance Testing"
.PP
Acceptance tests are written using the
.PDF_WWW_LINK https://robotframework.org/ "Robot Framework"
and
.PDF_WWW_LINK https://cucumber.io/ "cucumber"
testing frameworks. Robot Framework is a framework for generic test
automation. Cucumber is a framework for BDD (behaviour-driven development)
testing. Both frameworks are open source.
.PP
The acceptance tests also use
.PDF_WWW_LINK https://www.selenium.dev/ SUFFIX , "Selenium"
an open source framework for automated testing with a real web browser.
.HEADING 3 NAMED technologies_robot "Robot Framework Overview"
.PP
Robot Framework can be used for test automation and also for generic
automation. The project and its libraries are open source and free for use.
Robot Framework allows use of built-in, library-provided, or user-defined
"keywords". Keywords are high level operations or assertions that can be
used to define test cases or higher level keywords. The lowest level
keywords are written in either Python or Java. Higher level keywords are
written directly in Robot Framework syntax using a syntax very close to
natural language.
.PP
This is only a high level overview of Robot Framework. More details will
be discussed later in this report. This report does not attempt to cover
Robot Framework in full detail. To learn more about Robot Framework,
consult its
.PDF_WWW_LINK https://robotframework.org/#documentation SUFFIX . "documentation"
\#
.NEWPAGE
.HEADING 1 NAMED use_cases "Use Cases"
.HEADING 2 NAMED use_case_diagrams "Use Case Diagrams"
\#
\# Tables are really complicated, and use difficult to read stuf...
\# To really understand how this works, read chapter 5 of "Unix Text Processing"
\# in detail up to at least page 177 (inclusive).
\# Unix Text Processing: https://drive.google.com/file/d/128T-HMKbnDeYnLFzi714fZwytYsswS1z/view?usp=sharing
\# Also a good read is http://www.snake.net/software/troffcvt/tbl.html,
\# which for example covers the comma stuff below under 'Alternative notation'
\#
.FLOAT FORCE
.TS BOXED LABEL "Table 1: Use Case 1"
tab(@);
lI lB, lI l, lI l, lI l, lI l
lIT l, ^.
_
Use Case Identifier@UC1
_
Title@Login
_
Participating actor(s)@Dental staff member or client
_
Precondition(s)@System is ready to receive requests
_
Parameters@Username, password
_
T{
Flow of events
T}@1. System prompts for username and password
^@2. User submits their username and password
^@3. System logs the user in
^@4. User is redirected to homepage
_
.TE
.FLOAT OFF
\#
.FLOAT FORCE
.TS BOXED LABEL "Table 2: Use Case 2"
tab(@);
lI lB, lI l, lI l, lI l, lI l
lIT l, ^.
_
Use Case Identifier@UC2
_
Title@Logout
_
Participating actor(s)@Dental staff member or client
_
Precondition(s)@User is logged in
_
Parameters@None
_
T{
Flow of events
T}@1. User clicks Logout button
^@2. System logs the user out
^@3. User is redirected to Logout page
_
.TE
.FLOAT OFF
\#
.FLOAT FORCE
.TS BOXED LABEL "Table 3: Use Case 3"
tab(@);
lI lB, lI l, lI l, lI l, lI l
lIT l, ^.
_
Use Case Identifier@UC3
_
Title@Add new client
_
Participating actor(s)@Dental staff member
_
Precondition(s)@Dental staff member is logged in
_
Parameters@Client name, client address, client email, client phone number
_
T{
Flow of events
T}@1. Staff member selects "Register Client"
^@2. System displays page for adding a new client
^@3. Staff member enters the new client's information, including
^@name, address, email, and phone number
^@4. Staff member submits the client information
^@5. System adds the client's information to the database
^@6. System sends an email to the new client to complete their
^@registration
_
.TE
.FLOAT OFF
\#
.FLOAT FORCE
.TS BOXED LABEL "Table 4: Use Case 4"
tab(@);
lI lB, lI l, lI l,
lI l, ^, ^,
lI l,
lIT l, ^.
_
Use Case Identifier@UC4
_
Title@Client registration
_
Participating actor(s)@Dental client
_
T{
Precondition(s)
T}@The dental client's information has been added to the system by
^@a dental staff member; the client received an email to complete
^@registration
_
Parameters@Client name, client address, client email, client phone number
_
T{
Flow of events
T}@1. Client clicks on the link to complete registration in their
^@email
^@2. Client enters their username, desired password, and the
^@regisration token they were provided in the email
^@3. System redirects the client to the Login page
_
.TE
.FLOAT OFF
\#
.FLOAT FORCE
.TS BOXED LABEL "Table 5: Use Case 5"
tab(@);
lI lB, lI l, lI l, lI l, lI l
lIT l, ^.
_
Use Case Identifier@UC5
_
Title@Client view appointment
_
Participating actor(s)@Dental client
_
Precondition(s)@Client is logged in
_
Parameters@None
_
T{
Flow of events
T}@1. Client navigates to Appointments page
^@2. System displays all appointments for the client
^@3. Client selects an appointment to view
^@4. System displays appointment details
_
.TE
.FLOAT OFF
\#
.FLOAT FORCE
.TS BOXED LABEL "Table 6: Use Case 6"
tab(@);
lI lB, lI l, lI l, lI l, lI l
lIT l, ^.
_
Use Case Identifier@UC6
_
Title@Staff member view appointment
_
Participating actor(s)@Dental staff member
_
Precondition(s)@Staff member is logged in
_
Parameters@None
_
T{
Flow of events
T}@1. Staff member navigates to Appointments page
^@2. Staff member selects an appointment to view
^@3. System displays appointment details
_
.TE
.FLOAT OFF
\#
.FLOAT FORCE
.TS BOXED LABEL "Table 7: Use Case 7"
tab(@);
lI lB, lI l, lI l, lI l, lI l
lIT l, ^.
_
Use Case Identifier@UC7
_
Title@Staff member edit appointment
_
Participating actor(s)@Dental staff member
_
Precondition(s)@Staff member is logged in
_
Parameters@Date, time, client username, hygienist, operation, extra notes
_
T{
Flow of events
T}@1. Staff member selects an appointment to edit
^@2. Staff member edits the appointment
^@3. Staff member submits their edits
^@4. System stores the changes in the database
_
.TE
.FLOAT OFF
\#
.FLOAT FORCE
.TS BOXED LABEL "Table 8: Use Case 8"
tab(@);
lI lB, lI l, lI l, lI l, lI l
lIT l, ^.
_
Use Case Identifier@UC8
_
Title@Staff member create appointment
_
Participating actor(s)@Dental staff member
_
Precondition(s)@Staff member is logged in
_
Parameters@Date, time, client username, hygienist, operation, extra notes
_
T{
Flow of events
T}@1. Staff member selects "Create Appointment"
^@2. System displays Create Appointment page
^@3. Staff member enters appointment information, including client,
^@hygienist, appointment type, date, time, and extra notes
^@4. System stores the new appointment in the database
_
.TE
.FLOAT OFF
\#
.FLOAT FORCE
.TS BOXED LABEL "Table 9: Use Case 9"
tab(@);
lI lB, lI l, lI l, lI l, lI l
lIT l, ^.
_
Use Case Identifier@UC9
_
Title@Staff member cancel appointment
_
Participating actor(s)@Dental staff member
_
Precondition(s)@Staff member is logged in
_
Parameters@None
_
T{
Flow of events
T}@1. Staff member selects an appointment to cancel
^@2. Staff member selects "Cancel Appointment"
^@3. System deletes the appointment from the database
_
.TE
.FLOAT OFF
\#
.FLOAT FORCE
.TS BOXED LABEL "Table 10: Use Case 10"
tab(@);
lI lB, lI l, lI l, lI l, lI l
lIT l, ^.
_
Use Case Identifier@UC10
_
Title@Client view profile
_
Participating actor(s)@Dental client
_
Precondition(s)@Client is logged in
_
Parameters@None
_
T{
Flow of events
T}@1. Client navigates to Profile page
^@2. System displays the client's profile
_
.TE
.FLOAT OFF
\#
.FLOAT FORCE
.TS BOXED LABEL "Table 11: Use Case 11"
tab(@);
lI lB, lI l, lI l, lI l, lI l
lIT l, ^.
_
Use Case Identifier@UC11
_
Title@Staff member view profile
_
Participating actor(s)@Dental staff member
_
Precondition(s)@Staff member is logged in
_
Parameters@None
_
T{
Flow of events
T}@1. Staff member navigates to Clients page
^@2. System displays all clients
^@3. Staff member selects a client
^@4. System displays the client's profile
_
.TE
.FLOAT OFF
\#
.HEADING 2 "Use Case Activity Diagrams"
\#
.PDF_IMAGE img/uc1.pdf 657p 152p SCALE 70 CAPTION "Figure 1: Activity diagram for UC1"
.PDF_IMAGE img/uc2.pdf 345p 61p CAPTION "Figure 2: Activity diagram for UC2"
.NEWPAGE
.PDF_IMAGE img/uc3.pdf 517p 301p SCALE 75 CAPTION "Figure 3: Activity diagram for UC3"
.NEWPAGE
.PDF_IMAGE img/uc4.pdf 536p 459p SCALE 75 CAPTION "Figure 4: Activity diagram for UC4"
.PDF_IMAGE img/uc5.pdf 431p 54p CAPTION "Figure 5: Activity diagram for UC5"
.PDF_IMAGE img/uc6.pdf 335p 63p CAPTION "Figure 6: Activity diagram for UC6"
.PDF_IMAGE img/uc7.pdf 530p 531p SCALE 75 CAPTION "Figure 7: Activity diagram for UC7"
.NEWPAGE
.PDF_IMAGE img/uc8.pdf 533p 456p SCALE 75 CAPTION "Figure 8: Activity diagram for UC8"
.PDF_IMAGE img/uc9.pdf 323p 54p CAPTION "Figure 9: Activity diagram for UC9"
.PDF_IMAGE img/uc10.pdf 243p 65p CAPTION "Figure 10: Activity diagram for UC10"
.PDF_IMAGE img/uc11.pdf 423p 63p CAPTION "Figure 11: Activity diagram for UC11"
\#
.HEADING 1 NAMED testing "Testing"
.HEADING 2 NAMED testing_frontend "Frontend Testing"
.PP
As stated in
.PDF_LINK technologies_frontend SUFFIX , "\[sc]*"
the unit tests for the React frontend were written using the Jest
JavaScript testing framework. This section will not attempt to exhaustively
cover the features and usage details for this framework, as that is what
the
.PDF_WWW_LINK https://jestjs.io/docs/en/getting-started.html "Jest docs"
are for; rather, this section will describe the details necessary to
understand the Jest tests for this project.
.PP
Jest tests can be executed either by using \*[cod]jest\*[codx] or, if
\*[cod]react-scripts\*[codx] is installed, with
\*[cod]react-scripts test\*[codx]. The Jest test driver will search the
directory tree to find all files with names that match either the
\*[cod]*.test.js\*[codx] or \*[cod]*.spec.js\*[codx] pattern. Each of the
files matching one of these two patterns will then be executed by the Jest
test driver, and once execution is complete, the results are displayed.
.PP
Test files to be executed by Jest consist of \*[cod]describe()\*[codx],
\*[cod]it()\*[codx], \*[cod]test()\*[codx], and \*[cod]expect()\*[codx]
functions.
.PP
The \*[cod]describe()\*[codx] function simply provides a short
description of all of the tests inside it. Each \*[cod]it()\*[codx] and
\*[cod]test()\*[codx] constitutes a single test case. Test cases usually
have one or more assertion. Assertions are provided using
\*[cod]expect\*[codx]s. The full set of assertions provided by Jest can be
found
.PDF_WWW_LINK https://jestjs.io/docs/en/expect SUFFIX . "here"
.PP
Jest provides multiple ways to provide mocks. Mocks can be provided for
both JavaScript functions and classes. Full documentation for mocking
JavaScript ES6 classes can be accessed
.PDF_WWW_LINK https://jestjs.io/docs/en/es6-class-mocks SUFFIX . "here"
In this project, only some of these mocking methods were employed.
.PP
Jest can be told to mock a JavaScript module by first importing the module
and then calling \*[cod]jest.mock()\*[codx] on the module. For example, to
mock the \*[cod]axios\*[codx] module, first the module would be imported
as
.QUOTE
.CODE
import axios from 'axios';
.QUOTE OFF
then after all imports, \*[cod]jest.mock()\*[codx] would be called using
.QUOTE
.CODE
jest.mock('axios');
.QUOTE OFF
.PP
To cause a function in a mocked module to return a specific value, this
can be done using the \*[cod]mockResolvedValue()\*[codx] function. For
example, the \*[cod]axios.get()\*[codx] function can be mocked as follows:
.QUOTE
.CODE
const response = {/* Some predetermined desired response */};
axios.get.mockResolvedValue(response);
.QUOTE OFF
Then a call to \*[cod]axios.get()\*[codx] will return the specific response.
.PP
Functions defined by a module or class can also be replaced with a mock
implementation. For example, suppose we have the following JavaScript ES6
class:
.QUOTE
.CODE
class User {
    static isLoggedIn() {
        // Some implementation here
    }

    // Other functions
}
.QUOTE OFF
If we want to mock the \*[cod]static\*[codx] \*[cod]isLoggedIn()\*[codx]
function in a Jest test, we can do so like this:
.QUOTE
.CODE
User.isLoggedIn = jest.fn(() => {
    // Mock implementation here
});
.QUOTE OFF
.PP
For full-fledged examples of mocking with Jest, see
.PDF_WWW_LINK https://github.com/shanebishop/dental-appointment/blob/master/frontend/src/pages/pages/Appointments.test.js Appointments.test.js
and
.PDF_WWW_LINK https://github.com/shanebishop/dental-appointment/blob/master/frontend/src/routes/index.test.js index.test.js
in the GitHub repository for this project. See also following Jest
documentation pages:
.LIST
.SHIFT_LIST 2P+2p
.ITEM
.PDF_WWW_LINK https://jestjs.io/docs/en/mock-functions "Mocking Functions"
.ITEM
.PDF_WWW_LINK https://jestjs.io/docs/en/es6-class-mocks "JavaScript ES6 Class Mocks"
.ITEM
.PDF_WWW_LINK https://jestjs.io/docs/en/manual-mocks "Manual Mocking"
.LIST OFF
.HEADING 2 NAMED testing_backend "Backend Testing"
.PP
As stated in
.PDF_LINK technologies_backend SUFFIX , "\[sc]*"
the API tests for the backend were written using
Django's built-in testing framework. This built-in framework is further
augmented by the Django REST framework library, which includes Python
classes that allows for tests to be more expressed more clearly and
concisely.
.PP
The two Django REST framework classes used in the API tests are
.CODE
.PDF_WWW_LINK https://www.django-rest-framework.org/api-guide/testing/#api-test-cases APITestCase
.CODE OFF
and
.CODE
.PDF_WWW_LINK https://www.django-rest-framework.org/api-guide/testing/#apiclient SUFFIX . APIClient
.CODE OFF
\*[cod]APIClient\*[codx] is simply an HTTP client for making HTTP
requests. Responses can be analyzed for correctness. The
\*[cod]APITestCase\*[codx] class is a subclass of Django's
.CODE
.PDF_WWW_LINK https://docs.djangoproject.com/en/3.1/topics/testing/tools/#testcase TestCase
.CODE OFF
class where each instance of the class has a
\*[cod]APIClient\*[codx] instance.
.PP
Django's \*[cod]TestCase\*[codx] class is itself a subclass of
Python's built-in
.CODE
.PDF_WWW_LINK https://docs.python.org/3/library/unittest.html#unittest.TestCase unittest.TestCase
.CODE OFF
class. The
\*[cod]TestCase\*[codx] class, in addition to several assert functions,
defines the
.CODE
.PDF_WWW_LINK https://docs.python.org/3/library/unittest.html#unittest.TestCase.setUp setUp()
.CODE OFF
and
.CODE
.PDF_WWW_LINK https://docs.python.org/3/library/unittest.html#unittest.TestCase.tearDown tearDown()
.CODE OFF
functions. The \*[cod]setUp()\*[codx] function is called before the
execution of each test function defined in a \*[cod]TestCase\*[codx],
and the \*[cod]tearDown()\*[codx] function is called after the
execution of each test function in a \*[cod]TestCase\*[codx].
.PP
Helper functions can also be defined in a \*[cod]TestCase\*[codx]
class. To differentiate between helper functions and functions that
execute tests, all functions that execute tests must have function names
with the \*[cod]test\*[codx] prefix.\c
.FOOTNOTE
If desired, the prefix for a test function can be changed from the default
.CODE
test
.CODE OFF
to a different value, by using the
.CODE
.PDF_WWW_LINK https://docs.python.org/3/library/unittest.html#unittest.TestLoader.testMethodPrefix "unittest.TestLoader.testMethodPrefix"
.CODE OFF
.FOOTNOTE OFF
 If a function has a name that
does not begin with this prefix, it will not be executed as a test, and
will not contribute to the number of passing or failing tests.
.PP
For each API implemented in the Django backend, there is a corresponding
API test. Let us look at an example.
.FLOAT FORCE
.QUOTE
.CODE
def test_create_user(self):
    username = 'user1'
    data = generate_valid_user_data(username)

    response = self.client.post(
        RegisterUserAPITests.URL, data)
    self.assertIs(response.status_code, status.HTTP_200_OK)

    user = User.objects.get(username=username)
    user_data = UserData.objects.get(user=user)

    self.assertEqual(user.first_name, data['firstName'])
    self.assertEqual(user.last_name, data['surname'])
    self.assertEqual(user.email, data['email'])
    self.assertEqual(user_data.address1, data['address1'])
    self.assertEqual(user_data.address2, data['address2'])
    self.assertEqual(user_data.city, data['city'])
    self.assertEqual(user_data.province, data['province'])
    self.assertEqual(
        user_data.postalCode, data['postalCode'])
.QUOTE OFF
.FLOAT OFF
.PP
The function above is a test function, as indicated by the fact that its
name begins with the \*[cod]test\*[codx] prefix. From the name of the
function, it is clear that the action of creating a user is being tested.
First, valid user data is generated using a helper function (the code for
the helper function is omitted here for simplicity). Then the valid data
is sent to the URL for registering users using an HTTP POST request. The
HTTP response is stored in the \*[cod]response\*[codx] variable.
.PP
Next, there is an assert to test that the response's status code is the
HTTP 200 status code. If the assert fails, this test function would be
marked as failed, and no further assertions in the body of this function
would be executed.
.PP
To test the user was created successfully in the database, the data in the
database is retrieved with
.QUOTE
.CODE
user = User.objects.get(username=username)
user_data = UserData.objects.get(user=user)
.QUOTE OFF
Finally, all attributes of the data in the database is verified against
the data sent in the POST request with the remaining
\*[cod]assertEqual()\*[codx] asserts. If any assertion fails, this
test will fail.
\#
.HEADING 2 NAMED testing_acceptance "Acceptance Testing"
.PP
The acceptance tests were organized into files by webpage rather than by
use case. The table below shows which Robot Framework test suites and
cucumber scenarios provide test coverage for which use cases.
.PP
Note that all Robot Framework files are under the \*[cod]robot\*[codx]
directory, and all cucumber feature files are under the
\*[cod]cucumber/features\*[codx] directory.
.FLOAT FORCE
.TS BOXED LABEL "Table 11: Which Robot Framwork and cucumber files correspond to which use cases"
tab(@);
lB lB lB,
l l l.
_
Use Case@Robot Framework File@Cucumber File
_
UC1@login.robot@login.feature
_
UC2@logout.robot@N/A (see below)
_
UC3@register_user.robot@register_user.feature
_
UC4@complete_registration.robot@complete_registration.feature
_
UC5@appointments_list.robot@appointments_list.feature
_
UC6@appointments_list.robot@appointments_list.feature
_
UC7@update_appointment.robot@update_appointment.feature
_
UC8@create_appointment.robot@create_appointment.feature
_
UC9@appointments_list.robot@appointments_list.feature
_
UC10@profile_page.robot@profile_page.feature
_
UC11@clients_page.robot@clients_page.feature
_
.TE
.FLOAT OFF
.PP
There is no cucumber feature for UC2 because it would be difficult to
verify the deletion of browser cookies with native Selenium without the
Robot Framework Selenium keywords.
\#
.HEADING 2 NAMED test_files "Test Files"
.PP
This section explains how to find all the test files for each set of tests
for this project. All commands must be run in a UNIX shell. All commands,
except for the \*[cod]git clone\*[codx] command, must be in the project's
root directory.
.PP
To clone the Git repository, run
.QUOTE
.CODE
git clone https://github.com/shanebishop/dental-appointment.git
.QUOTE OFF
.PP
To get all frontend tests, run
.QUOTE
.CODE
find frontend/src -type f -name '*.test.js'
.QUOTE OFF
.PP
To get all backend tests, run
.QUOTE
.CODE
find backend -type f -name tests.py
.QUOTE OFF
.PP
To get all Robot Framework acceptance tests, run
.QUOTE
.CODE
find robot -type f -name '*.robot'
.QUOTE OFF
.PP
To get all cucumber acceptance tests, run
.QUOTE
.CODE
find cucumber/features -type f -name '*.feature'
.QUOTE OFF
.PP
Helper files with helper functions and code for the Robot Framework and cucumber
tests can be found in the \*[cod]robot\*[codx] and \*[cod]cucumber\*[codx]
directories, respectively.
\#
.HEADING 1 NAMED robot_cucumber "Comparing and Contrasing Robot Framework and Cucumber"
.HEADING 2 NAMED terminology_differences "Differences in Terminology"
.PP
There are some differences in the terminology used by Robot Framework and
cucumber in their documentation. In Robot Framework, each
\*[cod]\.robot\*[codx] file is refered to as a "test suite", whereas
cucumber refers to each \*[cod]\.feature\*[codx] file (the equivalent
of a \*[cod]\.robot\*[codx] file in cucumber) as a "feature". In cucumber,
each feature is broken into "scenarios", where each scenario consists of one
or more "steps". In Robot Framework, each test suite consists of one or
more "test cases". The Robot Framework documentation does not appear to
have a particular term for each line in a test case. Each line in a test
case consists of a keyword and its arguments.
.HEADING 2 NAMED scenaro_outline_vs_template "Robot Framework's Templates versus cucumber's Scenario Outlines
.PP
Robot Framework and cucumber have different ways of defining tests that
run for multiple data values. In Robot Framework these are called
"templates", and in cucumber these are called "scenario outlines".
.PP
To illustrate, two examples of an equivalent test are provided below for
both Robot Framework and cucumber.
.PP
Below is an example of a Robot Framework template:
.FLOAT FORCE
.QUOTE
.CODE
Invalid Login Tests
    [Template]  Invalid Login Should Fail
    invalid         invalid
    invalid         ${VALID PASSWORD}
    ${VALID USER}   invalid
    invalid         whatever
.QUOTE OFF
.FLOAT OFF
Here \*[cod]Invalid Login Should Fail\*[codx] is a keyword that takes two
arguments. The \*[cod][Template]\*[codx] indicates that the
\*[cod]Invalid Login Tests\*[codx] test case should be interpreted as a
template test case. The \*[cod]Invalid Login Should Fail\*[codx] keyword is
executed once for each line of arguments. For more details on Robot
Framework templates, see the
.PDF_WWW_LINK http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#test-templates SUFFIX . documentation
.PP
Below is an example of a cucumber scenario outline:
.FLOAT FORCE
.QUOTE
.CODE
Scenario Outline: Invalid login tests
  Given User is on login page
  When User enters username "<username>"
  And User enters password "<password>"
  And User submits credentials
  Then Failed login dialog contains message "expected message"

  Examples:
    | username | password |
    | invalid  | invalid  |
    | invalid  | admin    |
    | admin    | invalid  |
    | invalid  | whatever |
.QUOTE OFF
.FLOAT OFF
Here \*[cod]Scenario Outline\*[codx] indicates that this is a scenario
outline. The \*[cod]Examples\*[codx] table contains the data to be used to
be used to execute the scenario outline. The first line of the examples
is the names of each column of data. These names correspond to strings in
the scenario outline's steps within angle brackets. In the case of this
example, entries in the \*[cod]username\*[codx] column will be substituted for
the string \*[cod]<username>\*[codx] in the steps above, and the same will
be done for the \*[cod]password\*[codx] column. For more details about
cucumber scenario outlines, see the
.PDF_WWW_LINK https://cucumber.io/docs/gherkin/reference/#scenario-outline SUFFIX . documentation
\#
.HEADING 2 NAMED robot_cucumber_supported "Supported Languages"
.PP
Robot Framework keywords can be written only in Robot Framework,
Python, and Java. Cucumber supports writing steps in several different programming
languages. The table below shows which cucumber implementations are
official (i.e., hosted under the
.PDF_WWW_LINK https://github.com/cucumber SUFFIX ")," "GitHub Cucumber organization"
semi-official, unofficial, or unmaintained as of the time of writing.
.FLOAT FORCE
.TS BOXED LABEL "Table 12: Languages Supported by Cucumber"
tab(@);
lB lB lB lB,
l l l l.
_
Official@Semi-official@Unofficial@Unmaintained
_
Java@C#@Rust@Clojure
JavaScript@F#@D@Gosu
Ruby/Ruby on Rails@VB@@Groovy
OCaml@PHP@@JRuby
C++@Python@@Jython
Lua@Swift@@Rhino
Android (Java)@Objective C
Kotlin@Perl
Scala
Tcl
Go
_
.TE
.FLOAT OFF
.PP
See
.PDF_WWW_LINK https://cucumber.io/docs/installation/ here
for an up-to-date list of languages supported by cucumber.
\#
.HEADING 2 NAMED robot_advantages "Advantages of Robot Framework"
.PP
Robot Framework is actively supported, open source, and free to use and
extend. Several libraries and tools are available for use with Robot
Framework. The framework and its official libraries are well-documented.
.PP
Tests can be written in plain English (or in other natural languages),
which allow tests to be both read and written by non-technical members of a
project. Tests can also be easily read and understood by clients if clients
are involved in acceptance testing. Tests can be written in plaintext
without any markup (although Robot Framework is whitespace sensitive,
which has both advantages and disadvantages). This means tests can be
read and written by any text editor on any platform, and tests can be
easily version controlled.
.PP
Robot Framework test cases can be written using either Gerkin or regular
syntax. This allows testers to write their test casees to express how the
test is conducted as they wish \[en] they are not tied to a particular way
of expressing test cases.
.PP
Robot Framework provides hooks for executing setup and teardown keywords
before and after each test suite or test case.
.PP
Despite some of the disadvantages of Robot Framework being
whitespace-sensitive (see next section), there are also some advantages. The use of whitespace
to separate keyword arguments means there is no need to create regular
expressions to parse the arguments out, as is the case with cucumber.
.PP
Robot Framework also allows for using variables and control flow structures.
.PP
Variables can be created in Robot Framework in the global
scope, test suite scope (visible only within a single \*[cod].robot\*[codx]
file), or local scope (visible only within a single test case or keyword).
Global variables can be provided to the \*[cod]robot\*[codx] driver either
via the command line or via variable files. Variables allow for state to be
managed within test cases, which can allow keywords to be stateless.
For more details on variables, see the
.PDF_WWW_LINK http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#variables SUFFIX . "Variables section of the Robot Framework user guide"
.PP
Robot Framework supports the for loop control structure. This allows test authors to write looping code in a nearly
natural language syntax, as the conditional expressions and bodies of the
control structures are written in a natural language such as English. For
details on using for loops in Robot Framework, see the
.PDF_WWW_LINK http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#for-loops SUFFIX . "corresponding secction of the Robot Framework user guide"
.PP
Possibly the greatest advantage of Robot Framework is its keywords.
Robot keywords permit hiding low-level details from the definition of
higher-level keywords or test cases. This allows for faster writing of
test cases and also improves the readability of test cases. Lower level
keywords written in Robot Framework (rather than in Python or Java) also
continue to be readable to non-programmers. This means every level, from
test cases, to the highest level keywords, and then all the way down to the
lowest level keywords not in Python or Java, can all be designed to only
contain details relevant to how high-level or low-level the keyword or test
case is.
.PP
Beyond any user-defined keywords, Robot Framework also has built-in
keywords, and several official Robot Framework libraries that provide
additional keywords. The built-in keywords and library keywords, as with
any other Robot Framework keywords, can be used to create higher-level
user-defined keywords. The rich set of keywords available for use allows
testers to be very productive, as they do not need to spend any time
reinventing the wheel. The testers also don't need to be considered with
the added complexity and issues of maintaining their own custom helper
implementations for driving tests.
\#
.HEADING 2 NAMED robot_disadvantages "Disadvantages of Robot Framework"
.PP
Robot Framework currently only has support for defining keywords in Roboot
Framework, Python, and Java. This is not necesaarily problematic if Robot Framework
is being used to write acceptance tests, as is the case for this project,
but this can be a problem if it is being used for lower-level tests such as
unit tests. Unit tests should be written using the implementation language,
and if the implementation language is not Python or Java, then unit tests
cannot be written using Robot Framework.
.PP
Robot Framework is whitespace-sensitive. Arguments to keywords must be
separated by at least two characters of whitespace. Empty strings must be
specified with the special \*[cod]${EMPTY}\*[codx] variable. Whitespace
within arguments must be escaped.
.PP
Although relatively popular, Robot Framework is not as popular as cucumber.
Syntax highlighting and support for Robot Framework in most text editors and
IDEs requires installing a plugin. Sometimes the plugin is a community
plugin rather than an official plugin, and/or the plugin may have bugs or
not correctly apply syntax highlighting to new syntax available in the
latest Robot Framework release.
\#
.HEADING 2 NAMED cucumber_advantages "Advantages of Cucumber"
.PP
Cucumber is actively supported, open source, and free to use and
extend. Cucumber is also a very popular testing framework for acceptance
and behaviour driven testing.
.PP
Tests can be written in plain English (or in other natural languages),
which allow tests to be both read and written by non-technical members of a
project. Tests can also be easily read and understood by clients if clients
are involved in acceptance testing. Tests can be written in plaintext
without any markup. This means tests can be
read and written by any text editor on any platform, and tests can be
easily version controlled.
.PP
Cucumber officially supports implementing steps in several mainstream
programming languages, and unofficially supports implementing steps in some
other programming languages (see
.PDF_LINK robot_cucumber_supported SUFFIX ")." "\[sc]*"
.PP
Using regex to parse arguments to steps provides an advantages in
strongly typed languages, as then arguments can automatically be parsed to
the required types for each step's implementation.
\#
.HEADING 2 NAMED cucumber_disadvantages "Disadvantages of Cucumber"
.PP
Cucumber offers no official way to have setup and teardown code or steps
for features. The
.PDF_WWW_LINK https://github.com/cucumber/cucumber-jvm "cucumber-jvm repository on Github"
(for the Java
implementation of cucumber) has an
.PDF_WWW_LINK https://github.com/cucumber/cucumber-jvm/issues/515 issue
for adding
\*[cod]@BeforeAll\*[codx] and \*[cod]@AfterAll\*[codx] hooks, but at the
time of writing this issue is still open. Behave, the unofficial Python
implementation of cucumber and the implementation used for this project,
does have "before all" and "after all" hooks for features, but these are
shared by all features. Behave provides no way to specify custom "before
all" or "after all" hooks for individual features, should any particular
feature need its own custom setup or teardown operations.
.PP
With cucumber, state must be managed between individual steps. State management
can be done using classes (for object-oriented languages) or using contexts
(for non-object-oriented languages). However, the introduction of state
makes writing and debugging cucumber steps much more complicated then
when the steps are stateless. Of course, the person writing the cucumber
scenarios and steps can try to design them to be stateless, but sometimes
this is impossible, and then they must resort to managing state. At the
time of writing, cucumber offers no features to assist with state
management, so all state management must be done by the person programming
the steps.
.PP
State management can lead to either bugs that need to be fixed
(increasing the time required to write the scenarios), and may also tempt
step programmers to resort to global or global-like variables to share the
state across the various steps. If the programmers resort to using global
or global-like variables, then this may make the steps less modular and
less maintainable.
.PP
Cucumber has no built-in steps or libraries for common use. This means all
steps must be written by the project members themselves. If the cucumber
tests are very extensive and complex, the code for the steps might have
a great deal of helper code, or perhaps even its own modules and libraries
custom-developed for the project. In the worst case, then these test
libraries themselves need their own tests.
.PP
Cucumber has no built-in assertions. Assertions are necessary for testing,
as they provide a way to verify that the system under test behaves as
expected. If an assertion fails, then a test case can be marked as failed,
which indicates to the project members that there is a fault in their code
that requires their attention. Regardless of the language in use for
cucumber, since cucumber does not provide any built-in assertions, the
implementers of cucumber steps must use an assertion library available for
the implementation language, which increases the number of dependencies for
the project.
\#
\# This needs to be the very last macro
.TOC
