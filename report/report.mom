\#
\# groff-mom source for Honours Project report
\#
\# ===================================================================
\#
\# Metadata
\#
.\" .TITLE "Implementing and Testing a Dentistry Appointment System"
.\" .AUTHOR "Shane Bishop"
.ATTRIBUTE_STRING ""
.PRINTSTYLE TYPESET
\#
\# Set up Table of Contents
\#
.AUTO_RELOCATE_TOC AFTER_DOCCOVER
.SPACE_TOC_ITEMS
\#
\# Have captions after labels
\#
.CAPTION_AFTER_LABEL IMG
.CATPION_AFTER_LABEL TBL
\#
\# Use numbered footnotes
\#
.FOOTNOTE_MARKER_STYLE NUMBER
\# Set headings to be numbered
.HEADING_STYLE 1 NUMBER
.HEADING_STYLE 2 NUMBER
.HEADING_STYLE 3 NUMBER
.HEADING_STYLE 4 NUMBER
.HEADING_STYLE 5 NUMBER
\#
\# Pull the custom implementation of PDF_LINK macro from ~/pdf-link.tmac
\# For details, refer to previous email correspondence with Peter Schaffter
\#
.rm PDF_LINK
.mso pdf-link.tmac
\# Set indent for quoting
.QUOTE_INDENT 1
.\" Color for code snippets
.CODE_STYLE \
  FONT  B \
  SIZE  115 \
.CONDENSE 87 \" Condense percentage used in COD
.\" Strings for inline code
.ds cod  \E*[CODE]\&\E*[COND]
.ds codx \E*[CONDX]\E*[CODE off]\&
\#
\# Header stuff
\#
.HEADER_LEFT "Shane Bishop"
.HEADER_RIGHT "Implementing and Testing a Dentistry Appointment System"
.HEADER_RIGHT_CAPS OFF
\#
.DOC_COVERTEXT
.ALD 1.5i
.CENTER
.FT B
.PT_SIZE 18
Implementing and Testing a Dentistry Appointment System
.FT R
.PT_SIZE 12
.ALD 1i
Shane Bishop
.SP
Supervisor: Jean-Pierre Corriveau
.SP 3
April 23, 2021
.SP 3
COMP 4905 \[en] Honours Project
.SP 4
School of Computer Science
Carleton University
Ottawa, Ontario, Canada
.ALD 1.6i
.FT BI
.PT_SIZE 14
.LS 14
.CENTER
Abstract
.SP .5v
.FT R
.PT_SIZE 12
.JUSTIFY
In this project a client-server dentistry appointment system was built.
This system served as a software system to be tested on every level of its
"stack" using automated tests. The system was tested with unit tests,
REST API tests, and acceptance tests. Two competing frameworks for
acceptance testing, Robot Framework and cucumber, were compared and
contrasted.
.DOC_COVERTEXT OFF
.DOC_COVER DOC_COVERTEXT
\#
.START
\#
.HEADING 1 NAMED acknowledgments "Acknowledgments"
.PP
Thanks to my supervisor, Professor Jean-Pierre Corriveau, for answering my
questions related to this report and for his helpful feedback and
discussion with me throughout the process of completing this project.
.PP
Thanks to Peter Schaffter for his help working with the mom groff macros.
Mr. Schaffter was an excellent resource for help with building and
typesetting this report document. Thank you very much for your time.
.PP
I would like to thank and give credit to Himanshu Sheth.
Thank you for your informative and helpful article,
.PDF_WWW_LINK https://www.lambdatest.com/blog/selenium-python-behave-tutorial-bdd/ SUFFIX . "Selenium Python Tutorial: Getting Started With BDD In Behave"
This article was helpful for setting up boilerplate code for my cucumber
tests. Where code was based on code from this article, it is indicated by
a comment at the start of the file.
.PP
Thank you to James Chychota for exposing me to Django,
\*[cod]docker-compose\*[codx], and Nginx during my work at Nokia in 2020.
My initial exposure to these technologies greatly facilitated my ability to
learn more about and develop with these technologies while working on this
project.
.NEWPAGE
\#
.HEADING 1 NAMED intro "Introduction"
.PP
This report was written as part of the requirements for the Honours Project
completed by Shane Bishop, under the supervision of Professor Jean-Pierre
Corriveau, as part of the requirements for the Honours Bachelor of
Computer Science degree at Carleton University. This Honours Project was
completed during the Winter 2021 academic term.
.PP
This is a technical academic report. This report is written for readers with
a programming background with a working knowledge of software testing and
software quality assurance. Readers should be familiar with the Python and
JavaScript programming languages.
.PP
All source code developed to complete this projected is hosted in a Git
repository on GitHub. To request access to the repository,
email Shane Bishop at shanebishop@cmail.carleton.ca.
.HEADING 2 NAMED system_description "System Description"
.PP
The system developed for this project is a dentistry appointment system.
The system has a client-server architecture.
.PP
The client is a webapp. The webapp provides a graphical user interface for
the end users, which can be accessed by the users using a web browser.
.PP
The client communicates with the server via REST requests. The server
exposes a REST API to the client, which the client uses to send requests
to the server. The server supports multiple clients and was designed to
handle concurrent requests.
.PP
In the user interface, dental staff can edit and view appointments. Dental
clients can only view their own appointments and cannot edit their
appointments. Dental staff can edit and view appointments for all clients,
but clients can only view their own appointments. Only dental staff can
cancel appointments.
.HEADING 2 NAMED goals "Project Objectives"
.PP
This project has the following objectives:
.LIST
.SHIFT_LIST 2P+2p
.ITEM
Build a complete dental appointment system that satisfies the above system
description
.ITEM
Implement automated tests for testing the REST API endpoints exposed by the
server
.ITEM
Implement automated unit tests for the client
.ITEM
Implement automated acceptance tests for the client
.ITEM
Compare and contrast Robot Framework and cucumber as two competing
solutions for automated acceptance testing
.LIST OFF
\#
.HEADING 2 NAMED sections_intro "Report Sections"
.PP
Following this introduction, this report has the following sections:
Section 3 Tools and Technologies, Section 4 Use Cases, Section 5 Testing,
and Section 6 Comparing and Contrasting Robot Framework and Cucumber.
.PP
Section 3 introduces all of the software tools, technologies, and languages
used for both testing and development. Each subsection gives an overview of
the technologies used for the corresponding aspect of the project. These
overviews are very brief, with the exception of some further detail on
Django and React, since these technologies play a larger role in the
project.
.PP
Section 4 details the use cases. Section 4.2 uses UML activity diagrams to
model all possible "paths" through each use case. The arrows in each
activity diagram are labeled so that all "paths" through each use case can
be uniquely identified.
.PP
Section 5 provides details on testing. Sections 5.1 and 5.2 give a deep
drive on the frontend testing and backend testing, respectively. Section
5.3 explains how acceptance test files were organized, which
acceptance test files provide tests for which use cases, and provides
details on the concurrent test in Robot Framework. Section 5.4
provides commands for locating all test files based on testing type.
.PP
Section 6 gives an in-depth discussion and comparison of Robot Framework
and Cucumber as two competing testing tools.
\#
.HEADING 1 NAMED technologies "Tools and Technologies"
.PP
The Dental Appointments system is a full-stack webapp, consisting of a
frontend, backend server, and database. Each layer of the application has
its own tests as appropriate for the language or framework being used for
that layer. This section will describe all of the tools and technologies
employed by this system in terms of both implementation and testing.
.PP
None of the descriptions of the technologies given here should be treated
as substitutes for the official documentation for each technology. The
descriptions given here are only brief introductions for the reader. To
learn more about each technology, please consult the official
documentation.
.HEADING 2 NAMED technologies_frontend "Frontend"
.PP
The frontend is written in JavaScript using the
.PDF_WWW_LINK https://reactjs.org/ "React"
library. Unit tests for the react code were written using the
.PDF_WWW_LINK https://jestjs.io/ "Jest"
JavaScript testing framework.
.PP
React is a free, open source JavaScript library initially developed by
Facebook, and now maintained by Facebook and the React community. React
is centered around rendering to the browser's
.PDF_WWW_LINK https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model "DOM (Document Object Model)"
using React components.
.PP
React components are reusable UI components that
can be reused on multiple different pages of a webapp. Rendering is based
on the state of a component. Components are re-rendered on every state
change. For performance, React intelligently only re-renders parts of the
DOM that were affected by a state change. With this automatic re-rendering,
a page can be responsive to user interaction without a full page reload.
React webapps can "react" to users, hence where the library's name came
from.
.PP
A notable feature of React is JSX. JSX is an extension of the JavaScript
language syntax that permits developers to write psuedo-HTML for how each
React component will render. For more information, see
.PDF_WWW_LINK https://reactjs.org/docs/introducing-jsx.html SUFFIX . "the documentation"
.PP
React was chosen for this project because it is a powerful and mature
JavaScript UI library.
.PDF_WWW_LINK https://angular.io/ "Angular"
is a JavaScript UI library of comparable
power and maturity, but React was preferred because the author had
experience with React, and no experience yet in Angular.
.PDF_WWW_LINK https://vuejs.org/ "Vue.js"
is another JavaScript UI library, but this framework is very new and not
yet as powerful as React.
.PP
To learn more about React, a good starting point is the
.PDF_WWW_LINK https://reactjs.org/tutorial/tutorial.html SUFFIX , "online tutorial"
followed by the
.PDF_WWW_LINK https://reactjs.org/docs/hello-world.html SUFFIX . "main concepts guide"
.HEADING 2 NAMED technologies_backend "Backend"
.PP
The backend server is written in Python using the
.PDF_WWW_LINK https://www.djangoproject.com/ "Django"
framework. An
additional Python library called
.PDF_WWW_LINK https://www.django-rest-framework.org/ "Django REST framework"
was used to simplify the code for writing the REST APIs.
.PP
The Django framework includes its own built-in testing framework. The API
tests for the backend are written using this built-in testing framework.
.PP
The Django framework was written by web developers, for web developers. It
is a free and open source framework. Django was designed to be fast,
secure, and scalable. Much of the nitty-gritty low level details of a
web backend are handled behind the scenes by Django. Django allows for, and
encourages, writing clean, pythonic, high level code.
.PP
Another great strength of Django is that it handles all database details
for the developer. The developer is not required to write any database
queries by hand. All database details are abstracted away by Django's
.PDF_WWW_LINK https://docs.djangoproject.com/en/3.1/topics/db/models/ SUFFIX . models
All interactions with models are expressed directly in Python, and then
Django handles constructing and executing the equivalent database queries.
One huge benefit of this approach is that the database management system
(DBMS) used in a project can be swapped out without requiring any change to the
python code \[en] Django will automatically construct appropriate queries
for the new DBMS at runtime.
.PP
The Django REST framework is a natural extension to native Django, with the
same strengths as native Django. With the concept of
.PDF_WWW_LINK https://www.django-rest-framework.org/api-guide/views/ SUFFIX , views
the Django REST framework permits developers to write very little code to
produce APIs for various data models.
.PP
The Django framework was chosen for this project because it is free,
it is a mature web framework, and because of the ease of development
using this framework.
.PP
To learn more about Django and the Django REST framework, the best initial
starting points are the
.PDF_WWW_LINK https://docs.djangoproject.com/en/3.1/intro/tutorial01/ "Django tutorial"
and the
.PDF_WWW_LINK https://www.django-rest-framework.org/tutorial/quickstart/ SUFFIX . "Django REST Framework tutorial"
The full online Django documentation can be found
.PDF_WWW_LINK https://docs.djangoproject.com SUFFIX . "here"
.HEADING 2 NAMED technologies_database "Database"
.PP
The database uses the
.PDF_WWW_LINK https://www.postgresql.org/ "PostgreSQL"
relational database management system.
However, the Django framework used in the backend abstracts away all of the
details of PostgreSQL (or any alternative database management system), which
means no actual PostgreSQL code was written "by hand" for this project.
.HEADING 2 NAMED technologies_deployment "Deployment"
.PP
The system is spun up using Docker and \*[cod]docker-compose\*[codx].
.PP
.PDF_WWW_LINK https://www.docker.com/ "Docker"
is a container technology that allows for running an application
under controlled and isolated conditions, often used for fast and easy
application development and deployment. Docker supports reproducible builds,
and any Docker "image" can be rebuilt from the same specification.
.PP
.CODE
.PDF_WWW_LINK https://docs.docker.com/compose/ "docker-compose"
.CODE OFF
is a Docker tool that uses declarative code to define the
deployment of a system consisting of several individual Docker containers.
.PP
This project also uses
.PDF_WWW_LINK https://www.nginx.com/ "Nginx"
to connect the different components of the system over the Docker virtual
network. Nginx is a free, open source networking tool with many uses, including serving as a
web server, load balancer, reverse proxy, or API gateway.
.HEADING 2 NAMED technologies_acceptance "Acceptance Testing"
.PP
Acceptance tests are written using the
.PDF_WWW_LINK https://robotframework.org/ "Robot Framework"
and
.PDF_WWW_LINK https://cucumber.io/ "cucumber"
testing frameworks. Robot Framework is a framework for generic test
automation. Cucumber is a framework for BDD (behaviour-driven development)
testing. Both frameworks are open source.
.PP
The acceptance tests also use
.PDF_WWW_LINK https://www.selenium.dev/ SUFFIX , "Selenium"
an open source framework for automated testing with a real web browser.
.HEADING 3 NAMED technologies_robot "Robot Framework Overview"
.PP
Robot Framework can be used for test automation and also for generic
automation. The project and its libraries are open source and free for use.
Robot Framework allows use of built-in, library-provided, or user-defined
"keywords". Keywords are high level operations or assertions that can be
used to define test cases or higher level keywords. The lowest level
keywords are written in either Python or Java. Higher level keywords are
written directly in Robot Framework syntax using a syntax very close to
natural language.
.PP
This is only a high level overview of Robot Framework. More details will
be discussed later in this report. This report does not attempt to cover
Robot Framework in full detail. To learn more about Robot Framework,
consult its
.PDF_WWW_LINK https://robotframework.org/#documentation SUFFIX . "documentation"
\#
.HEADING 3 NAMED behave "Python Behave and PyHamcrest Libraries"
.PP
For this project, all cucumber steps were implemented in Python using the
.PDF_WWW_LINK https://behave.readthedocs.io/en/stable/ "behave"
Python implementation of cucumber. It may be useful to read the
.PDF_WWW_LINK https://behave.readthedocs.io/en/stable/tutorial.html "behave tutorial"
before reading the step definitions for this project. All step definitions
can be found in the \*[cod]cucumber/features/steps\*[codx] directory of
this project's source code.
.PP
Since cucumber does not provide assertions natively (in any implementation
language), the
.PDF_WWW_LINK https://pyhamcrest.readthedocs.io/en/latest/ "PyHamcrest"
Python assertion library was used to make assertions in the step
definitions.
.NEWPAGE
.HEADING 1 NAMED use_cases "Use Cases"
.HEADING 2 NAMED use_case_diagrams "Use Case Diagrams"
\#
\# Tables are really complicated, and use difficult to read stuff...
\# To really understand how this works, read chapter 5 of "Unix Text Processing"
\# in detail up to at least page 177 (inclusive).
\# Unix Text Processing: https://drive.google.com/file/d/128T-HMKbnDeYnLFzi714fZwytYsswS1z/view?usp=sharing
\# Also a good read is http://www.snake.net/software/troffcvt/tbl.html,
\# which for example covers the comma stuff below under 'Alternative notation'
\#
.FLOAT FORCE
.TS BOXED LABEL "Table 1: Use Case 1"
tab(@);
lI lB, lI l, lI l, lI l, lI l
lIT l, ^.
_
Use Case Identifier@UC1
_
Title@Login
_
Participating actor(s)@Dental staff member or client
_
Precondition(s)@System is ready to receive requests
_
Parameters@Username, password
_
T{
Flow of events
T}@1. System prompts for username and password
^@2. User submits their username and password
^@3. System logs the user in
^@4. User is redirected to homepage
_
.TE
.FLOAT OFF
\#
.FLOAT FORCE
.TS BOXED LABEL "Table 2: Use Case 2"
tab(@);
lI lB, lI l, lI l, lI l, lI l
lIT l, ^.
_
Use Case Identifier@UC2
_
Title@Logout
_
Participating actor(s)@Dental staff member or client
_
Precondition(s)@User is logged in
_
Parameters@None
_
T{
Flow of events
T}@1. User clicks Logout button
^@2. System logs the user out
^@3. User is redirected to Logout page
_
.TE
.FLOAT OFF
\#
.FLOAT FORCE
.TS BOXED LABEL "Table 3: Use Case 3"
tab(@);
lI lB, lI l, lI l, lI l, lI l
lIT l, ^.
_
Use Case Identifier@UC3
_
Title@Add new client
_
Participating actor(s)@Dental staff member
_
Precondition(s)@Dental staff member is logged in
_
Parameters@Client name, client address, client email, client phone number
_
T{
Flow of events
T}@1. Staff member selects "Register Client"
^@2. System displays page for adding a new client
^@3. Staff member enters the new client's information, including
^@name, address, email, and phone number
^@4. Staff member submits the client information
^@5. System adds the client's information to the database
^@6. System sends an email to the new client to complete their
^@registration
_
.TE
.FLOAT OFF
\#
.FLOAT FORCE
.TS BOXED LABEL "Table 4: Use Case 4"
tab(@);
lI lB, lI l, lI l,
lI l, ^, ^,
lI l,
lIT l, ^.
_
Use Case Identifier@UC4
_
Title@Client registration
_
Participating actor(s)@Dental client
_
T{
Precondition(s)
T}@The dental client's information has been added to the system by
^@a dental staff member; the client received an email to complete
^@registration
_
Parameters@Client name, client address, client email, client phone number
_
T{
Flow of events
T}@1. Client clicks on the link to complete registration in their
^@email
^@2. Client enters their username, desired password, and the
^@regisration token they were provided in the email
^@3. System redirects the client to the Login page
_
.TE
.FLOAT OFF
\#
.FLOAT FORCE
.TS BOXED LABEL "Table 5: Use Case 5"
tab(@);
lI lB, lI l, lI l, lI l, lI l
lIT l, ^.
_
Use Case Identifier@UC5
_
Title@Client view appointment
_
Participating actor(s)@Dental client
_
Precondition(s)@Client is logged in
_
Parameters@None
_
T{
Flow of events
T}@1. Client navigates to Appointments page
^@2. System displays all appointments for the client
^@3. Client selects an appointment to view
^@4. System displays appointment details
_
.TE
.FLOAT OFF
\#
.FLOAT FORCE
.TS BOXED LABEL "Table 6: Use Case 6"
tab(@);
lI lB, lI l, lI l, lI l, lI l
lIT l, ^.
_
Use Case Identifier@UC6
_
Title@Staff member view appointment
_
Participating actor(s)@Dental staff member
_
Precondition(s)@Staff member is logged in
_
Parameters@None
_
T{
Flow of events
T}@1. Staff member navigates to Appointments page
^@2. Staff member selects an appointment to view
^@3. System displays appointment details
_
.TE
.FLOAT OFF
\#
.FLOAT FORCE
.TS BOXED LABEL "Table 7: Use Case 7"
tab(@);
lI lB, lI l, lI l, lI l, lI l
lIT l, ^.
_
Use Case Identifier@UC7
_
Title@Staff member edit appointment
_
Participating actor(s)@Dental staff member
_
Precondition(s)@Staff member is logged in
_
Parameters@Date, time, client username, hygienist, operation, extra notes
_
T{
Flow of events
T}@1. Staff member selects an appointment to edit
^@2. Staff member edits the appointment
^@3. Staff member submits their edits
^@4. System stores the changes in the database
_
.TE
.FLOAT OFF
\#
.FLOAT FORCE
.TS BOXED LABEL "Table 8: Use Case 8"
tab(@);
lI lB, lI l, lI l, lI l, lI l
lIT l, ^.
_
Use Case Identifier@UC8
_
Title@Staff member create appointment
_
Participating actor(s)@Dental staff member
_
Precondition(s)@Staff member is logged in
_
Parameters@Date, time, client username, hygienist, operation, extra notes
_
T{
Flow of events
T}@1. Staff member selects "Create Appointment"
^@2. System displays Create Appointment page
^@3. Staff member enters appointment information, including client,
^@hygienist, appointment type, date, time, and extra notes
^@4. System stores the new appointment in the database
_
.TE
.FLOAT OFF
\#
.FLOAT FORCE
.TS BOXED LABEL "Table 9: Use Case 9"
tab(@);
lI lB, lI l, lI l, lI l, lI l
lIT l, ^.
_
Use Case Identifier@UC9
_
Title@Staff member cancel appointment
_
Participating actor(s)@Dental staff member
_
Precondition(s)@Staff member is logged in
_
Parameters@None
_
T{
Flow of events
T}@1. Staff member selects an appointment to cancel
^@2. Staff member selects "Cancel Appointment"
^@3. System deletes the appointment from the database
_
.TE
.FLOAT OFF
\#
.FLOAT FORCE
.TS BOXED LABEL "Table 10: Use Case 10"
tab(@);
lI lB, lI l, lI l, lI l, lI l
lIT l, ^.
_
Use Case Identifier@UC10
_
Title@Client view profile
_
Participating actor(s)@Dental client
_
Precondition(s)@Client is logged in
_
Parameters@None
_
T{
Flow of events
T}@1. Client navigates to Profile page
^@2. System displays the client's profile
_
.TE
.FLOAT OFF
\#
.FLOAT FORCE
.TS BOXED LABEL "Table 11: Use Case 11"
tab(@);
lI lB, lI l, lI l, lI l, lI l
lIT l, ^.
_
Use Case Identifier@UC11
_
Title@Staff member view profile
_
Participating actor(s)@Dental staff member
_
Precondition(s)@Staff member is logged in
_
Parameters@None
_
T{
Flow of events
T}@1. Staff member navigates to Clients page
^@2. System displays all clients
^@3. Staff member selects a client
^@4. System displays the client's profile
_
.TE
.FLOAT OFF
\#
.HEADING 2 "Use Case Activity Diagrams"
.PP
This section has the activity diagrams for each use case. Each activity
diagram has a one-to-one mapping to a use case. Each arrow in each
activity diagram is labeled so that paths through each use case can be
uniquely identified.
.PP
In the Robot Framework and cucumber acceptance tests,
each test case (Robot Framework) and scenario (cucumber) that corresponds
to a path in one of these activity diagrams has a comment
indicating which path the test case or scenario tests.
\#
.PDF_IMAGE img/uc1.pdf 657p 152p SCALE 70 CAPTION "Figure 1: Activity diagram for UC1"
.PDF_IMAGE img/uc2.pdf 345p 61p CAPTION "Figure 2: Activity diagram for UC2"
.NEWPAGE
.PDF_IMAGE img/uc3.pdf 517p 301p SCALE 75 CAPTION "Figure 3: Activity diagram for UC3"
.NEWPAGE
.PDF_IMAGE img/uc4.pdf 536p 459p SCALE 75 CAPTION "Figure 4: Activity diagram for UC4"
.PDF_IMAGE img/uc5.pdf 431p 54p CAPTION "Figure 5: Activity diagram for UC5"
.PDF_IMAGE img/uc6.pdf 335p 63p CAPTION "Figure 6: Activity diagram for UC6"
.PDF_IMAGE img/uc7.pdf 530p 531p SCALE 75 CAPTION "Figure 7: Activity diagram for UC7"
.NEWPAGE
.PDF_IMAGE img/uc8.pdf 533p 456p SCALE 75 CAPTION "Figure 8: Activity diagram for UC8"
.PDF_IMAGE img/uc9.pdf 323p 54p CAPTION "Figure 9: Activity diagram for UC9"
.PDF_IMAGE img/uc10.pdf 243p 65p CAPTION "Figure 10: Activity diagram for UC10"
.PDF_IMAGE img/uc11.pdf 423p 63p CAPTION "Figure 11: Activity diagram for UC11"
\#
.HEADING 1 NAMED testing "Testing"
.HEADING 2 NAMED testing_frontend "Frontend Testing"
.PP
As stated in
.PDF_LINK technologies_frontend SUFFIX , "\[sc]*"
the unit tests for the React frontend were written using the Jest
JavaScript testing framework. This section will not attempt to exhaustively
cover the features and usage details for this framework, as that is what
the
.PDF_WWW_LINK https://jestjs.io/docs/en/getting-started.html "Jest docs"
are for; rather, this section will describe the details necessary to
understand the Jest tests for this project.
.PP
Jest tests can be executed either by using \*[cod]jest\*[codx] or, if
\*[cod]react-scripts\*[codx] is installed, with
\*[cod]react-scripts test\*[codx]. The Jest test driver will search the
directory tree to find all files with names that match either the
\*[cod]*.test.js\*[codx] or \*[cod]*.spec.js\*[codx] pattern. Each of the
files matching one of these two patterns will then be executed by the Jest
test driver, and once execution is complete, the results are displayed.
.PP
Test files to be executed by Jest consist of \*[cod]describe()\*[codx],
\*[cod]it()\*[codx], \*[cod]test()\*[codx], and \*[cod]expect()\*[codx]
functions.
.PP
The \*[cod]describe()\*[codx] function simply provides a short
description of all of the tests inside it. Each \*[cod]it()\*[codx] and
\*[cod]test()\*[codx] constitutes a single test case. Test cases usually
have one or more assertion. Assertions are provided using
\*[cod]expect\*[codx]s. The full set of assertions provided by Jest can be
found
.PDF_WWW_LINK https://jestjs.io/docs/en/expect SUFFIX . "here"
.PP
Jest provides multiple ways to provide mocks. Mocks can be provided for
both JavaScript functions and classes. Full documentation for mocking
JavaScript ES6 classes can be accessed
.PDF_WWW_LINK https://jestjs.io/docs/en/es6-class-mocks SUFFIX . "here"
In this project, only some of these mocking methods were employed.
.PP
Jest can be told to mock a JavaScript module by first importing the module
and then calling \*[cod]jest.mock()\*[codx] on the module. For example, to
mock the \*[cod]axios\*[codx] module, first the module would be imported
as
.QUOTE
.CODE
import axios from 'axios';
.QUOTE OFF
then after all imports, \*[cod]jest.mock()\*[codx] would be called using
.QUOTE
.CODE
jest.mock('axios');
.QUOTE OFF
.PP
To cause a function in a mocked module to return a specific value, this
can be done using the \*[cod]mockResolvedValue()\*[codx] function. For
example, the \*[cod]axios.get()\*[codx] function can be mocked as follows:
.QUOTE
.CODE
const response = {/* Some predetermined desired response */};
axios.get.mockResolvedValue(response);
.QUOTE OFF
Then a call to \*[cod]axios.get()\*[codx] will return the specific response.
.PP
Functions defined by a module or class can also be replaced with a mock
implementation. For example, suppose we have the following JavaScript ES6
class:
.QUOTE
.CODE
class User {
    static isLoggedIn() {
        // Some implementation here
    }

    // Other functions
}
.QUOTE OFF
If we want to mock the \*[cod]static\*[codx] \*[cod]isLoggedIn()\*[codx]
function in a Jest test, we can do so like this:
.QUOTE
.CODE
User.isLoggedIn = jest.fn(() => {
    // Mock implementation here
});
.QUOTE OFF
.PP
For full-fledged examples of mocking with Jest, see
.PDF_WWW_LINK https://github.com/shanebishop/dental-appointment/blob/master/frontend/src/pages/pages/Appointments.test.js Appointments.test.js
and
.PDF_WWW_LINK https://github.com/shanebishop/dental-appointment/blob/master/frontend/src/routes/index.test.js index.test.js
in the GitHub repository for this project. See also following Jest
documentation pages:
.LIST
.SHIFT_LIST 2P+2p
.ITEM
.PDF_WWW_LINK https://jestjs.io/docs/en/mock-functions "Mocking Functions"
.ITEM
.PDF_WWW_LINK https://jestjs.io/docs/en/es6-class-mocks "JavaScript ES6 Class Mocks"
.ITEM
.PDF_WWW_LINK https://jestjs.io/docs/en/manual-mocks "Manual Mocking"
.LIST OFF
.HEADING 2 NAMED testing_backend "Backend Testing"
.PP
As stated in
.PDF_LINK technologies_backend SUFFIX , "\[sc]*"
the API tests for the backend were written using
Django's built-in testing framework. This built-in framework is further
augmented by the Django REST framework library, which includes Python
classes that allows for tests to be more expressed more clearly and
concisely.
.PP
The two Django REST framework classes used in the API tests are
.CODE
.PDF_WWW_LINK https://www.django-rest-framework.org/api-guide/testing/#api-test-cases APITestCase
.CODE OFF
and
.CODE
.PDF_WWW_LINK https://www.django-rest-framework.org/api-guide/testing/#apiclient SUFFIX . APIClient
.CODE OFF
\*[cod]APIClient\*[codx] is simply an HTTP client for making HTTP
requests. Responses can be analyzed for correctness. The
\*[cod]APITestCase\*[codx] class is a subclass of Django's
.CODE
.PDF_WWW_LINK https://docs.djangoproject.com/en/3.1/topics/testing/tools/#testcase TestCase
.CODE OFF
class where each instance of the class has a
\*[cod]APIClient\*[codx] instance.
.PP
Django's \*[cod]TestCase\*[codx] class is itself a subclass of
Python's built-in
.CODE
.PDF_WWW_LINK https://docs.python.org/3/library/unittest.html#unittest.TestCase unittest.TestCase
.CODE OFF
class. The
\*[cod]TestCase\*[codx] class, in addition to several assert functions,
defines the
.CODE
.PDF_WWW_LINK https://docs.python.org/3/library/unittest.html#unittest.TestCase.setUp setUp()
.CODE OFF
and
.CODE
.PDF_WWW_LINK https://docs.python.org/3/library/unittest.html#unittest.TestCase.tearDown tearDown()
.CODE OFF
functions. The \*[cod]setUp()\*[codx] function is called before the
execution of each test function defined in a \*[cod]TestCase\*[codx],
and the \*[cod]tearDown()\*[codx] function is called after the
execution of each test function in a \*[cod]TestCase\*[codx].
.PP
Helper functions can also be defined in a \*[cod]TestCase\*[codx]
class. To differentiate between helper functions and functions that
execute tests, all functions that execute tests must have function names
with the \*[cod]test\*[codx] prefix.\c
.FOOTNOTE
If desired, the prefix for a test function can be changed from the default
.CODE
test
.CODE OFF
to a different value, by using the
.CODE
.PDF_WWW_LINK https://docs.python.org/3/library/unittest.html#unittest.TestLoader.testMethodPrefix "unittest.TestLoader.testMethodPrefix"
.CODE OFF
.FOOTNOTE OFF
 If a function has a name that
does not begin with this prefix, it will not be executed as a test, and
will not contribute to the number of passing or failing tests.
.PP
For each API implemented in the Django backend, there is a corresponding
API test. Let us look at an example.
.FLOAT FORCE
.QUOTE
.CODE
def test_create_user(self):
    username = 'user1'
    data = generate_valid_user_data(username)

    response = self.client.post(
        RegisterUserAPITests.URL, data)
    self.assertIs(response.status_code, status.HTTP_200_OK)

    user = User.objects.get(username=username)
    user_data = UserData.objects.get(user=user)

    self.assertEqual(user.first_name, data['firstName'])
    self.assertEqual(user.last_name, data['surname'])
    self.assertEqual(user.email, data['email'])
    self.assertEqual(user_data.address1, data['address1'])
    self.assertEqual(user_data.address2, data['address2'])
    self.assertEqual(user_data.city, data['city'])
    self.assertEqual(user_data.province, data['province'])
    self.assertEqual(
        user_data.postalCode, data['postalCode'])
.QUOTE OFF
.FLOAT OFF
.PP
The function above is a test function, as indicated by the fact that its
name begins with the \*[cod]test\*[codx] prefix. From the name of the
function, it is clear that the action of creating a user is being tested.
First, valid user data is generated using a helper function (the code for
the helper function is omitted here for simplicity). Then the valid data
is sent to the URL for registering users using an HTTP POST request. The
HTTP response is stored in the \*[cod]response\*[codx] variable.
.PP
Next, there is an assert to test that the response's status code is the
HTTP 200 status code. If the assert fails, this test function would be
marked as failed, and no further assertions in the body of this function
would be executed.
.PP
To test the user was created successfully in the database, the data in the
database is retrieved with
.QUOTE
.CODE
user = User.objects.get(username=username)
user_data = UserData.objects.get(user=user)
.QUOTE OFF
Finally, all attributes of the data in the database is verified against
the data sent in the POST request with the remaining
\*[cod]assertEqual()\*[codx] asserts. If any assertion fails, this
test will fail.
\#
.HEADING 2 NAMED testing_acceptance "Acceptance Testing"
.PP
The acceptance tests were organized into files by webpage rather than by
use case. The table below shows which Robot Framework test suites and
cucumber scenarios provide test coverage for which use cases.
.PP
Note that all Robot Framework files are under the \*[cod]robot\*[codx]
directory, and all cucumber feature files are under the
\*[cod]cucumber/features\*[codx] directory.
.FLOAT
.TS BOXED LABEL "Table 11: Which Robot Framework and cucumber files correspond to which use cases"
tab(@);
lB lB lB,
l l l.
_
Use Case@Robot Framework File@Cucumber File
_
UC1@login.robot@login.feature
_
UC2@logout.robot@N/A (see below)
_
UC3@register_user.robot@register_user.feature
_
UC4@complete_registration.robot@complete_registration.feature
_
UC5@appointments_list.robot@appointments_list.feature
_
UC6@appointments_list.robot@appointments_list.feature
_
UC7@update_appointment.robot@update_appointment.feature
_
UC8@create_appointment.robot@create_appointment.feature
_
UC9@appointments_list.robot@appointments_list.feature
_
UC10@profile_page.robot@profile_page.feature
_
UC11@clients_page.robot@clients_page.feature
_
.TE
.FLOAT OFF
.PP
There is no cucumber feature for UC2 because it would be difficult to
verify the deletion of browser cookies with native Selenium without the
Robot Framework Selenium keywords.
\#
.HEADING 3 NAMED concurrent_tests "Concurrent Acceptance Test"
.PP
There is one acceptance test for a concurrent operation. The test was written
only in Robot Framework for simplicity. The file with this test is
.PDF_WWW_LINK https://github.com/shanebishop/dental-appointment/blob/master/robot/concurrent_create_appointment.robot SUFFIX . "concurrent_create_appointment.robot"
The \*[cod]Create Appointments Concurrently\*[codx] Robot Framework keyword is
implemented in
.PDF_WWW_LINK https://github.com/shanebishop/dental-appointment/blob/master/robot/CustomHelpers/Appointments.py "Appointments.py"
Python file with the \*[cod]create_appointments_concurrently()\*[codx] function.
.PP
The purpose of this test is to ensure that, even with concurrent create
appointment requests, only one appointment will be created if the appointments
are for the same date, time, and client. If two appointment requests are sent
with the same date, time, and client, one request should be successful, and the
other request should be unsuccessful. For the unsuccessful request, the response
should have the appropriate error message.
.PP
Since, with concurrent operations, the execution order is non-deterministic, the
Robot Framework test case executes the
\*[cod]Create Appointments Concurrently\*[codx] keyword multiple times to
hopefully cause both possible orderings to occur.
.PP
The \*[cod]create_appointments_concurrently()\*[codx] function creates a
\*[cod]ThreadPoolExecutor\*[codx] for multithreading. Then the helper
\*[cod]_create_appointment()\*[codx] function is executed in two threads. The
helper function makes the actual request to the backend server.
.PP
Once both requests have completed and responses have been received, there are
assertions to verify correctness. Firstly, there is a check that there are
exactly two responses. Next, there is a check that one request had a success
status code response, and that the other request has an error status code. These
two assertions are performed with Python's \*[cod]in\*[codx] operator to avoid being
concerned which of the two requests succeeded or failed. Next, again using the
\*[cod]in\*[codx] operator, there are assertions to check there is one success
response message and one error message. The assertion for the error message
specifically checks that the error message indicates a time and date conflict
for the client.
\#
.HEADING 2 NAMED test_files "Test Files"
.PP
This section explains how to find all the test files for each set of tests
for this project. All commands must be run in a UNIX shell. All commands,
except for the \*[cod]git clone\*[codx] command, must be in the project's
root directory.
.PP
To clone the Git repository, run
.QUOTE
.CODE
git clone https://github.com/shanebishop/dental-appointment.git
.QUOTE OFF
.PP
To get all frontend tests, run
.QUOTE
.CODE
find frontend/src -type f -name '*.test.js'
.QUOTE OFF
.PP
To get all backend tests, run
.QUOTE
.CODE
find backend -type f -name tests.py
.QUOTE OFF
.PP
To get all Robot Framework acceptance tests, run
.QUOTE
.CODE
find robot -type f -name '*.robot'
.QUOTE OFF
.PP
To get all cucumber acceptance tests, run
.QUOTE
.CODE
find cucumber/features -type f -name '*.feature'
.QUOTE OFF
.PP
Helper files with helper functions and code for the Robot Framework and cucumber
tests can be found in the \*[cod]robot\*[codx] and \*[cod]cucumber\*[codx]
directories, respectively.
\#
.HEADING 1 NAMED robot_cucumber "Comparing and Contrasting Robot Framework and Cucumber"
.HEADING 2 NAMED terminology_differences "Differences in Terminology"
.PP
There are some differences in the terminology used by Robot Framework and
cucumber in their documentation. In Robot Framework, each
\*[cod]\.robot\*[codx] file is referred to as a "test suite", whereas
cucumber refers to each \*[cod]\.feature\*[codx] file (the equivalent
of a \*[cod]\.robot\*[codx] file in cucumber) as a "feature". In cucumber,
each feature is broken into "scenarios", where each scenario consists of one
or more "steps". In Robot Framework, each test suite consists of one or
more "test cases". The Robot Framework documentation does not appear to
have a particular term for each line in a test case. Each line in a test
case consists of a keyword and its arguments.
.HEADING 2 NAMED scenario_outline_vs_template "Robot Framework's Templates versus cucumber's Scenario Outlines
.PP
Robot Framework and cucumber have different ways of defining tests that
run for multiple data values. In Robot Framework these are called
"templates", and in cucumber these are called "scenario outlines".
.PP
To illustrate, two examples of an equivalent test are provided below for
both Robot Framework and cucumber.
.PP
Below is an example of a Robot Framework template:
.FLOAT FORCE
.QUOTE
.CODE
Invalid Login Tests
    [Template]  Invalid Login Should Fail
    invalid         invalid
    invalid         ${VALID PASSWORD}
    ${VALID USER}   invalid
    invalid         whatever
.QUOTE OFF
.FLOAT OFF
.PP
Here \*[cod]Invalid Login Should Fail\*[codx] is a keyword that takes two
arguments. The \*[cod][Template]\*[codx] indicates that the
\*[cod]Invalid Login Tests\*[codx] test case should be interpreted as a
template test case. The \*[cod]Invalid Login Should Fail\*[codx] keyword is
executed once for each line of arguments. For more details on Robot
Framework templates, see the
.PDF_WWW_LINK http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#test-templates SUFFIX . documentation
.PP
Below is an example of a cucumber scenario outline:
.FLOAT FORCE
.QUOTE
.CODE
Scenario Outline: Invalid login tests
  Given User is on login page
  When User enters username "<username>"
  And User enters password "<password>"
  And User submits credentials
  Then Failed login dialog contains message "expected message"

  Examples:
    | username | password |
    | invalid  | invalid  |
    | invalid  | admin    |
    | admin    | invalid  |
    | invalid  | whatever |
.QUOTE OFF
.FLOAT OFF
Here \*[cod]Scenario Outline\*[codx] indicates that this is a scenario
outline. The \*[cod]Examples\*[codx] table contains the data to be used to
be used to execute the scenario outline. The first line of the examples
is the names of each column of data. These names correspond to strings in
the scenario outline's steps within angle brackets. In the case of this
example, entries in the \*[cod]username\*[codx] column will be substituted for
the string \*[cod]<username>\*[codx] in the steps above, and the same will
be done for the \*[cod]password\*[codx] column. For more details about
cucumber scenario outlines, see the
.PDF_WWW_LINK https://cucumber.io/docs/gherkin/reference/#scenario-outline SUFFIX . documentation
\#
.HEADING 2 NAMED robot_cucumber_supported "Supported Languages"
.PP
Robot Framework keywords can be written only in Robot Framework,
Python, and Java. Cucumber supports writing steps in several different programming
languages. The table below shows which cucumber implementations are
official (i.e., hosted under the
.PDF_WWW_LINK https://github.com/cucumber SUFFIX ")," "GitHub Cucumber organization"
semi-official, unofficial, or unmaintained as of the time of writing.
.FLOAT
.TS BOXED LABEL "Table 12: Languages Supported by Cucumber"
tab(@);
lB lB lB lB,
l l l l.
_
Official@Semi-official@Unofficial@Unmaintained
_
Java@C#@Rust@Clojure
JavaScript@F#@D@Gosu
Ruby/Ruby on Rails@VB@@Groovy
OCaml@PHP@@JRuby
C++@Python@@Jython
Lua@Swift@@Rhino
Android (Java)@Objective C
Kotlin@Perl
Scala
Tcl
Go
_
.TE
.FLOAT OFF
.PP
See
.PDF_WWW_LINK https://cucumber.io/docs/installation/ here
for an up-to-date list of languages supported by cucumber.
\#
.HEADING 2 NAMED robot_advantages "Advantages of Robot Framework"
.PP
Robot Framework is actively supported, open source, and free to use and
extend. Several libraries and tools are available for use with Robot
Framework. The framework and its official libraries are well-documented.
.PP
Tests can be written in plain English (or in other natural languages),
which allow tests to be both read and written by non-technical members of a
project. Tests can also be easily read and understood by clients if clients
are involved in acceptance testing. Tests can be written in plaintext
without any markup (although Robot Framework is whitespace sensitive,
which has both advantages and disadvantages). This means tests can be
read and written by any text editor on any platform, and tests can be
easily version controlled.
.PP
Robot Framework test cases can be written using either Gherkin or regular
syntax. This allows testers to write their test cases to express how the
test is conducted as they wish \[en] they are not tied to a particular way
of expressing test cases.
.PP
Robot Framework provides hooks for executing setup and teardown keywords
before and after each test suite or test case.
.PP
Despite some of the disadvantages of Robot Framework being
whitespace-sensitive (see next section), there are also some advantages. The use of whitespace
to separate keyword arguments means there is no need to create regular
expressions to parse the arguments out, as is the case with cucumber.
.PP
Robot Framework also allows for using variables and control flow structures.
.PP
Variables can be created in Robot Framework in the global
scope, test suite scope (visible only within a single \*[cod].robot\*[codx]
file), or local scope (visible only within a single test case or keyword).
Global variables can be provided to the \*[cod]robot\*[codx] driver either
via the command line or via variable files. Variables allow for state to be
managed within test cases, which can allow keywords to be stateless.
For more details on variables, see the
.PDF_WWW_LINK http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#variables SUFFIX . "Variables section of the Robot Framework user guide"
.PP
Robot Framework supports the for loop control structure. This allows test authors to write looping code in a nearly
natural language syntax, as the conditional expressions and bodies of the
control structures are written in a natural language such as English. For
details on using for loops in Robot Framework, see the
.PDF_WWW_LINK http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#for-loops SUFFIX . "corresponding section of the Robot Framework user guide"
.PP
Possibly the greatest advantage of Robot Framework is its keywords.
Robot keywords permit hiding low-level details from the definition of
higher-level keywords or test cases. This allows for faster writing of
test cases and also improves the readability of test cases. Lower level
keywords written in Robot Framework (rather than in Python or Java) also
continue to be readable to non-programmers. This means every level, from
test cases, to the highest level keywords, and then all the way down to the
lowest level keywords not in Python or Java, can all be designed to only
contain details relevant to how high-level or low-level the keyword or test
case is.
.PP
Beyond any user-defined keywords, Robot Framework also has built-in
keywords, and several official Robot Framework libraries that provide
additional keywords. The built-in keywords and library keywords, as with
any other Robot Framework keywords, can be used to create higher-level
user-defined keywords. The rich set of keywords available for use allows
testers to be very productive, as they do not need to spend any time
reinventing the wheel. The testers also don't need to be considered with
the added complexity and issues of maintaining their own custom helper
implementations for driving tests.
\#
.HEADING 2 NAMED robot_disadvantages "Disadvantages of Robot Framework"
.PP
Robot Framework currently only has support for defining keywords in Robot
Framework, Python, and Java. This is not necessarily problematic if Robot Framework
is being used to write acceptance tests, as is the case for this project,
but this can be a problem if it is being used for lower-level tests such as
unit tests. Unit tests should be written using the implementation language,
and if the implementation language is not Python or Java, then unit tests
cannot be written using Robot Framework.
.PP
Robot Framework is whitespace-sensitive. Arguments to keywords must be
separated by at least two characters of whitespace. Empty strings must be
specified with the special \*[cod]${EMPTY}\*[codx] variable. Whitespace
within arguments must be escaped.
.PP
Although relatively popular, Robot Framework is not as popular as cucumber.
Syntax highlighting and support for Robot Framework in most text editors
and IDEs requires installing a plugin. Sometimes the plugin is a community
plugin rather than an official plugin, and/or the plugin may have bugs or
not correctly apply syntax highlighting to new syntax available in the
latest Robot Framework release.
.PP
In the default log level, the line number of the keyword a test case
fails on is not displayed in the console output. Instead, only the error
message for the failing keyword is printed, without any context other
than knowing which test case failed. Knowing the line number of the
keyword that caused the test case to fail would
considerably speed up the time required to debug a failing test case.
\#
.HEADING 2 NAMED cucumber_advantages "Advantages of Cucumber"
.PP
Cucumber is actively supported, open source, and free to use and
extend. Cucumber is also a very popular testing framework for acceptance
and behaviour driven testing.
.PP
Tests can be written in plain English (or in other natural languages),
which allow tests to be both read and written by non-technical members of a
project. Tests can also be easily read and understood by clients if clients
are involved in acceptance testing. Tests can be written in plaintext
without any markup. This means tests can be
read and written by any text editor on any platform, and tests can be
easily version controlled.
.PP
Cucumber officially supports implementing steps in several mainstream
programming languages, and unofficially supports implementing steps in some
other programming languages (see
.PDF_LINK robot_cucumber_supported SUFFIX ")." "\[sc]*"
.PP
Using regex to parse arguments to steps provides an advantages in
strongly typed languages, as then arguments can automatically be parsed to
the required types for each step's implementation.
\#
.HEADING 2 NAMED cucumber_disadvantages "Disadvantages of Cucumber"
.PP
Cucumber offers no official way to have setup and teardown code or steps
for features. The
.PDF_WWW_LINK https://github.com/cucumber/cucumber-jvm "cucumber-jvm repository on GitHub"
(for the Java
implementation of cucumber) has an
.PDF_WWW_LINK https://github.com/cucumber/cucumber-jvm/issues/515 issue
for adding
\*[cod]@BeforeAll\*[codx] and \*[cod]@AfterAll\*[codx] hooks, but at the
time of writing this issue is still open. Behave, the unofficial Python
implementation of cucumber and the implementation used for this project,
does have "before all" and "after all" hooks for features, but these are
shared by all features. Behave provides no way to specify custom "before
all" or "after all" hooks for individual features, should any particular
feature need its own custom setup or teardown operations.
.PP
With cucumber, state must be managed between individual steps. State management
can be done using classes (for object-oriented languages) or using contexts
(for non-object-oriented languages). However, the introduction of state
makes writing and debugging cucumber steps much more complicated then
when the steps are stateless. Of course, the person writing the cucumber
scenarios and steps can try to design them to be stateless, but sometimes
this is impossible, and then they must resort to managing state. At the
time of writing, cucumber offers no features to assist with state
management, so all state management must be done by the person programming
the steps.
.PP
State management can lead to either bugs that need to be fixed
(increasing the time required to write the scenarios), and may also tempt
step programmers to resort to global or global-like variables to share the
state across the various steps. If the programmers resort to using global
or global-like variables, then this may make the steps less modular and
less maintainable.
.PP
Cucumber has no built-in steps or libraries for common use. This means all
steps must be written by the project members themselves. If the cucumber
tests are very extensive and complex, the code for the steps might have
a great deal of helper code, or perhaps even its own modules and libraries
custom-developed for the project. In the worst case, then these test
libraries themselves need their own tests.
.PP
Cucumber has no built-in assertions. Assertions are necessary for testing,
as they provide a way to verify that the system under test behaves as
expected. If an assertion fails, then a test case can be marked as failed,
which indicates to the project members that there is a fault in their code
that requires their attention. Regardless of the language in use for
cucumber, since cucumber does not provide any built-in assertions, the
implementers of cucumber steps must use an assertion library available for
the implementation language, which increases the number of dependencies for
the project.
\#
\# This needs to be the very last macro
.TOC
